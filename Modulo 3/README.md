# Proyecto 3: Máquina de Galton

En este proyecto la complejidad para comprender el proyecto fué muy grande, en lo personal estuve batallando y tardando para comprender que era lo que se debía hacer. Fué relativamente sencillo el comprender el funcionamiento del modelo de la máquina, pero no se me ocurría ninguna manera de representarlo en un lenguaje de programación.
Busqué si era por switch, if, ciclos, pedir al usuario información, y tardé en comprender como es que debería hacerlo. Tuve que leer y releer el proyecto para poder llegar a una conclusión y que se pudiera implementar en python.

Primero entendí que era una repetición de eventos de cada canica, ahí el primer ciclo; posterior entendí que en cada canica hay que aplicar varias veces un avance derecha o izquierda, y aquí e donde me quedé más atorado porque no sabía como interpretar esos movimientos hasta que entendí que con un ciclo que estuviera repitiendo el movimiento y que iba a ser aleatorio, es decir, aplicar el random aprendido en clase; pero no era suficiente porque todavía faltaba saber el movimiento donde iba a quedar la canica. Este fué otro gran obstáculo ya que no sabía como interpretarlo hasta que ví que era tan simple como un arreglo.

Ya que tenía los arreglos, los movimientos aleatorios y el arreglo donde se iba a almacenar la canica, ahora era momento de saber como ir dando seguimiento a estos movimientos; de acuerdo al problema descrito, físicamente las canicas se vierten en el modelo de la máquina desde el centro del mismo, eso quise hacer indicando que la posición inicial iba a ser la mitad del arreglo y que cada vez que se moviera a la izquiera o derecha de manera aleatoria movería la canica de posición, gravísimo error porque el arreglo aparecía sí de manera aleatoria, pero nunca distribuida como en la máquina del ejemplo.

De tanto pensar y descartar ideas, simplemente le indiqué que comenzara al inicio, como cualquier arreglo en la posición inicial del mismo, y que los movimientos no me interesaban ir dando seguimiento sino solamente la posición final; pero aún no sabía como moverlo, entonces revisando ví que usaba valores de 1 y 2 para izquierda y derecha respectivamente, ya hacía un agregar y restar posiciones, por lo que intenté solamente agregar posición si se movía a la derecha ya que el arreglo comenzaría de una manera lógica de lado izquierdo y entonces solo cuando se moviera a la derecha se agregaría una posición; a lo largo de los movimientos aleatorios se iría sumando posiciones cuando se moviera a la derecha y permanecería si apareciera moverse a la izquierda, es decir, usar 0 para movimiento izquierdo y 1 para derecho.

Fué bastante complicado y eso me gustó, hizo que me pusiera a pensar durante varias horas el como solucionarlo. La parte gráfica fué algo más sencillo pero busqué apoyo en internet para configurar tanto los colores, título, descripción de los ejes y que al final mostrara el resultado final.
